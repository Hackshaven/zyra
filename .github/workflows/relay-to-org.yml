name: Relay Codex PRs to NOAA-GSL/zyra

on:
  pull_request_target:
    types: [opened, reopened, synchronize, edited, closed]
    branches:
      - mirror/staging
      # - 'mirror/**'   # uncomment to allow any mirror/* base
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Downstream PR number in HacksHaven/zyra (optional: selects latest open mirror/* PR if empty)"
        required: false
        type: number

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ${{ format('relay-{0}-{1}', github.event_name, github.event.inputs.pr_number || github.event.pull_request.number) }}
  cancel-in-progress: true

env:
  ORG_OWNER: NOAA-GSL
  ORG_REPO: zyra
  RELAY_BASE: staging

jobs:
  relay:
    name: Mirror PR to org (create/update/close)
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Resolve PR context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const isManual = context.eventName === 'workflow_dispatch';
            let pr;

            if (isManual) {
              const raw = core.getInput('pr_number', { required: false });
              if (raw) {
                const prNumber = Number(raw);
                const { data } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                pr = data;
              } else {
                const list = await github.paginate(github.rest.pulls.list, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 50
                });
                pr = list.find(p => p.base?.ref?.startsWith('mirror/'));
                if (!pr) {
                  core.setFailed("No open PRs found targeting 'mirror/*'. Provide pr_number when running manually.");
                  return;
                }
              }
            } else {
              pr = context.payload.pull_request;
            }

            if (pr.head.repo.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
              core.setFailed(`PR head repo ${pr.head.repo.full_name} is not this repository; cannot access secrets.`);
              return;
            }

            if (!pr.base || !pr.base.ref.startsWith('mirror/')) {
              core.setFailed(`Base branch '${pr.base?.ref}' is not a mirror/* branch.`);
              return;
            }

            core.setOutput('pr_number', String(pr.number));
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_sha', pr.head.sha);
            core.setOutput('head_repo', pr.head.repo.full_name);
            core.setOutput('is_closed', String(pr.state === 'closed'));

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.ctx.outputs.head_repo }}
          ref: ${{ steps.ctx.outputs.head_sha }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "relay-bot"
          git config user.email "relay-bot@example.com"
          git config advice.skippedCherryPicks false

      - name: Ensure upstream base exists
        env:
          ORG_TOKEN: ${{ secrets.SYNC_PAT_ORG }}
        run: |
          set -euo pipefail
          git ls-remote "https://x-access-token:${ORG_TOKEN}@github.com/${{ env.ORG_OWNER }}/${{ env.ORG_REPO }}.git" "refs/heads/${{ env.RELAY_BASE }}" | grep -q . || \
            (echo "::error ::${{ env.ORG_OWNER }}/${{ env.ORG_REPO }}:${{ env.RELAY_BASE }} not found" && exit 1)

      - name: Add upstream and fetch base
        env:
          ORG_TOKEN: ${{ secrets.SYNC_PAT_ORG }}
        run: |
          set -euo pipefail
          git remote add upstream "https://x-access-token:${ORG_TOKEN}@github.com/${{ env.ORG_OWNER }}/${{ env.ORG_REPO }}.git"
          git fetch upstream "${{ env.RELAY_BASE }}"

      - name: Rebase onto upstream base (looping auto-resolve, LFS/binary-generic)
        id: rebase
        shell: bash
        run: |
          set -euo pipefail
          export GIT_EDITOR=true

          # Kick off rebase; keep going even if it errors, we'll resolve iteratively
          git rebase "upstream/${{ env.RELAY_BASE }}" || true

          # Allowlist to favor upstream ("theirs")
          ALLOWLIST_REGEX=(
            # infra/dev
            "^\\.devcontainer/.*$"
            "^docker-compose\\.yml$"
            "^Dockerfile$"
            # dependency manifests & locks
            "^pyproject\\.toml$"
            "^poetry\\.lock$"
            "^package\\.json$"
            "^package-lock\\.json$"
            "^pnpm-lock\\.yaml$"
            "^yarn\\.lock$"
            # version constants (Python)
            "^src/.*/__init__\\.py$"
            # workflows (never relay local)
            "^\\.github/workflows/.*$"
          )

          matches_allowlist () {
            local f="$1"
            for rx in "${ALLOWLIST_REGEX[@]}"; do
              if [[ "$f" =~ $rx ]]; then
                return 0
              fi
            done
            return 1
          }

          is_lfs_tracked () {
            local f="$1"
            # Requires .gitattributes present; returns 0 if filter=lfs
            local out
            out="$(git check-attr filter -- "$f" 2>/dev/null || true)"
            [[ "$out" == *"filter: lfs"* ]]
          }

          is_binary_by_numstat () {
            local f="$1"
            # Binary files show -  - in numstat
            local num
            num="$(git diff --numstat -- "$f" 2>/dev/null || true)"
            [[ "$num" == -*"-"* ]]
          }

          stage_has_lfs_pointer () {
            # Check if a given stage (1=base,2=ours,3=theirs) looks like an LFS pointer
            local stage="$1"; local f="$2"
            git show ":${stage}:${f}" 2>/dev/null | head -n 1 | grep -q "version https://git-lfs.github.com/spec"
          }

          is_lfs_or_binary () {
            local f="$1"
            if is_lfs_tracked "$f"; then return 0; fi
            if is_binary_by_numstat "$f"; then return 0; fi
            # Fallback: pointer check in any stage
            stage_has_lfs_pointer 1 "$f" && return 0
            stage_has_lfs_pointer 2 "$f" && return 0
            stage_has_lfs_pointer 3 "$f" && return 0
            return 1
          }

          resolve_binary_like () {
            local f="$1"
            # Try deletion acceptance first (handles modify/delete)
            git rm -f -- "$f" 2>/dev/null || true
            # If deletion didn't apply, take upstream content
            git checkout --theirs -- "$f" 2>/dev/null || true
            git add -- "$f" 2>/dev/null || true
          }

          iter=0
          max_iter=200
          while [[ -d .git/rebase-merge || -d .git/rebase-apply ]]; do
            ((iter++)) || true
            if (( iter > max_iter )); then
              echo "Iteration cap hit during rebase; aborting."
              echo "conflict=true" >> "$GITHUB_OUTPUT"
              git rebase --abort || true
              exit 0
            fi

            conflicted="$(git diff --name-only --diff-filter=U || true)"

            if [[ -z "$conflicted" ]]; then
              # Try to advance; if it fails, re-check next loop
              git rebase --continue || { sleep 1; continue; }
              continue
            fi

            resolved_any=false
            non_allowlisted_text=false

            while IFS= read -r f; do
              [[ -z "$f" ]] && continue
              if matches_allowlist "$f"; then
                echo "  ‚Ä¢ Auto-resolving (prefer upstream) $f"
                git checkout --theirs -- "$f" || true
                git add "$f" || true
                resolved_any=true
              elif is_lfs_or_binary "$f"; then
                echo "  ‚Ä¢ Auto-resolving (LFS/binary prefer upstream) $f"
                resolve_binary_like "$f"
                resolved_any=true
              else
                echo "  ‚Ä¢ Non-allowlisted, non-binary conflict: $f"
                non_allowlisted_text=true
              fi
            done <<< "$conflicted"

            if [[ "$resolved_any" == "true" ]]; then
              git rebase --continue || true
              continue
            fi

            if [[ "$non_allowlisted_text" == "true" ]]; then
              echo "Remaining conflicts are outside allowlist and not binary/LFS; cannot auto-resolve safely."
              echo "conflict=true" >> "$GITHUB_OUTPUT"
              git rebase --abort || true
              exit 0
            fi

            echo "Stuck during rebase without resolvable files."
            echo "conflict=true" >> "$GITHUB_OUTPUT"
            git rebase --abort || true
            exit 0
          done

          echo "conflict=" >> "$GITHUB_OUTPUT"

      - name: Comment on rebase conflict (downstream PR)
        if: steps.rebase.outputs.conflict == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.ctx.outputs.pr_number }}')
            const body = [
              "‚ùå Relay rebase hit conflicts against **" + process.env.ORG_OWNER + "/" + process.env.ORG_REPO + ":" + process.env.RELAY_BASE + "**.",
              "",
              "I auto-resolved infra, dependency manifests/locks, version files, workflows, and **any LFS/binary files (detected generically)** by preferring upstream.",
              "Conflicts remain in non-allowlisted text files.",
              "",
              "**Action:** Rebase your branch on `mirror/staging` locally, resolve remaining conflicts, and push again.",
              "",
              "**Tip:** Keep large/binary asset changes out of Codex feature PRs when possible; coordinate them upstream directly."
            ].join("\n");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });
            core.setFailed('Rebase conflict after auto-resolve')

      - name: Push relay branch to org
        if: ${{ steps.rebase.outputs.conflict != 'true' && steps.ctx.outputs.is_closed != 'true' }}
        env:
          ORG_TOKEN: ${{ secrets.SYNC_PAT_ORG }}
        run: |
          set -euo pipefail
          RELAY_BRANCH="relay/hh-pr-${{ steps.ctx.outputs.pr_number }}"
          git push "https://x-access-token:${ORG_TOKEN}@github.com/${{ env.ORG_OWNER }}/${{ env.ORG_REPO }}.git" HEAD:${RELAY_BRANCH} --force-with-lease
          echo "RELAY_BRANCH=${RELAY_BRANCH}" >> $GITHUB_ENV

      - name: Create or update PR in org
        if: ${{ steps.rebase.outputs.conflict != 'true' && steps.ctx.outputs.is_closed != 'true' }}
        id: upsert
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SYNC_PAT_ORG }}
          script: |
            const relayBranch = process.env.RELAY_BRANCH;
            const owner = process.env.ORG_OWNER;
            const repo  = process.env.ORG_REPO;
            const base  = process.env.RELAY_BASE;
            const prNumber = Number('${{ steps.ctx.outputs.pr_number }}');

            const { data: srcPR } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber
            });
            const title = `Codex Relay: ${context.repo.owner}/${context.repo.repo} PR #${prNumber} ‚Äî ${srcPR.title}`;
            const body  = `Mirrored from **${context.repo.owner}/${context.repo.repo}** PR #${prNumber}\n\nSource: ${srcPR.html_url}\n\n> This PR is maintained by an automated relay. Changes should be made in the original HH PR.`;

            const existing = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', head: `${owner}:${relayBranch}` });
            let url;
            if (existing.length > 0) {
              await github.rest.pulls.update({ owner, repo, pull_number: existing[0].number, title, body });
              url = existing[0].html_url;
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, head: relayBranch, base, title, body });
              url = pr.data.html_url;
            }
            core.setOutput('org_pr_url', url)

      - name: Comment upstream PR link on downstream PR
        if: ${{ steps.upsert.outputs.org_pr_url }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number('${{ steps.ctx.outputs.pr_number }}')
            const url = '${{ steps.upsert.outputs.org_pr_url }}'
            const body = `üîÅ Relay created/updated upstream PR: ${url}`
            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body })

      - name: Close matching org PR when HH PR closes
        if: ${{ steps.ctx.outputs.is_closed == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SYNC_PAT_ORG }}
          script: |
            const owner = process.env.ORG_OWNER;
            const repo  = process.env.ORG_REPO;
            const prNumber = Number('${{ steps.ctx.outputs.pr_number }}')
            const relayBranch = `relay/hh-pr-${prNumber}`;
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', head: `${owner}:${relayBranch}` });
            for (const pr of prs) {
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, state: 'closed' });
              core.info(`Closed org PR #${pr.number} because HH PR #${prNumber} was closed.`);
            }
